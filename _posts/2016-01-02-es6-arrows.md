---
layout: post
title: ES6 Arrows
---

#### Getting started with ES6

ES6? Cool! Can I use it? The short answer is yes* (cross your fingers). [Check out this awesome table of features and where they are supported.](https://kangax.github.io/compat-table/es6/) __Link TL;DR:__ Decent desktop support of Firefox, Edge (MS finally ditched IE and made something awesome), Chrome (with 'use strict'). Somethings work on Node, Safari is still 'meh' and there is limited ES6 support on mobile browsers.

The current solution to improve compatibility is to transpile your ES6 code to ES5 using something like [Babel](https://babeljs.io/) or [Traceur](https://github.com/google/traceur-compiler). I use Babel because at the moment it has slightly better feature support and an awesome [repl](https://babeljs.io/repl/).

### Arrows - shorter functions

According to [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) the two biggest motivations for arrows were shorter functions and lexical `this`.

Short and sweet in ES6:

```js
var add = (x , y) => x + y;

// using var instead of let for readers unfamiliar with ES6 block scoping
```

Transpiles to slightly more verbose ES5 implementation:

```js
"use strict";

var add = function add (x, y) {
  return x + y;
};
// technically the second 'add' can be removed shortening to just 'function (x, y)'
```
Arrows save having to write `function` & `return` for simple functions like this. When only one variable is used, the parenthesis can also be omitted `x => x * x`, I always keep the parens for consistency. To return object literals they need to be wrapped in parenthesis. Arrows can also be as [IIFEs](http://benalman.com/news/2010/11/immediately-invoked-function-expression/). Also included [transpiled to ES5](https://goo.gl/qD64JO).

```js
(() => "I'm an IIFE")() //IIFE

var foobar = () => ({foo: 'bar'}) // Object Literal
```

Arrows can also be used with block statements It should be noted that in blocks the `return` is not automatic and needs to be explicitly stated. This still saves having to write `function`. ES6 arrows with blocks - [transpiled to ES5](https://goo.gl/nSfBOH):

```js
$('#pizza-btn').click( (event) => {
  preheatOven();
  pizzaInOven();
  return 'I love za!'
});
```

Shorter syntax is awesome, especially because I'm always misspelling `funciton`.

### Lexical This

The rest of the post assumes you are comfortable with scope, context, and closures in javascript. Detailed reviews of these concepts can be found [here](https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/), [here](http://ryanmorr.com/understanding-scope-and-context-in-javascript/), and [here](http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/). The TL;DR:  __Context__ refers to the object that the currently executing function is attached to - determined in most cases by how a function is called. The value of `this` references whatever the current context is. __Scope__ is where a variable can be referenced (where it's defined).

Where arrows really shine is by binding `this`. It's worth noting, as  [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) points out, that arrows don't bind their 'own this, arguments, super, or new.target'. The `this` in an arrow  is set to the this value of the enclosing execution context.

Here we have a function, in this case an Object constructor function. Inside this function is a method that executes a callback function. We want the ovenTemp of the Oven to increase every 1000 ms.

```js
function Oven () {
  this.ovenTemp = 0; // here `this` references instance of Oven constructor

  setInterval(function preheatOven() {
    // preheatOven() redefines context of `this`
    this.ovenTemp++;  // here `this` references the global object, undesired action
  }, 1000);
}
```
The Oven.ovenTemp doesn't change because our callback changed the context of `this`. We can remedy the problem by [binding](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) `this`.

```js
function Oven () {
  this.ovenTemp = 0; // here `this` references instance of Oven constructor

  setInterval(function preheatOven() {
    // preheatOven() redefines context of `this`
    this.ovenTemp++;  // here `this` references the global object, undesired action
  }, 1000).bind(this);
}
```
Another, more performant, way to fix the problem is to store the top level `this` reference/context in a variable, commonly seen as `self = this` or `that = this`.

```js
function Oven () {
  var self = this; // stores top level `this` reference
  self.ovenTemp = 0;

  setInterval(function preheatOven() {

    self.ovenTemp++; // performs desired action
  }, 1000);
}
```
A better solution is to leverage the lexical scoping of arrow functions.

```js
function Oven () {
  this.ovenTemp = 0;

  setInterval( preheatOven = () => {
    this.ovenTemp++;  // here `this` references instance of Oven constructor, as desired
  }, 1000);
}
```
In this particular example we can use an anonymous callback and refactor to one line. Wow that's pretty!

```js
function Oven () {
  this.ovenTemp = 0;
  setInterval( () => { this.ovenTemp++; }, 1000);
}
```

This trivial example shows a non trivial use case - arrows can simplify callbacks and/or closures and allow for more intuitive use of context.

### Bonus - ES6 method definition syntax

Another way you can avoid typing `funciton` in ES6 is with the new syntax for [method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions). Super helpful!

```js
//ES6
var obj = {
  foo: 'foobar', // same syntax as ES5
  bar() {}
};

// Transpiled into ES5
var obj = {
  foo: 'foobar', // same syntax as ES6
  bar: function bar() {} //`bar: function() {}` is equally valid
};
```

### Additional Resources

- [ES6 In Depth: Arrow functions](https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/)
- [ES6 arrow functions, syntax and lexical scoping](https://toddmotto.com/es6-arrow-functions-syntaxes-and-lexical-scoping/)

---

 __Blog disclaimer:__ This blog exists to help me learn things and share that process with anyone in a similar spot in knowledge. A lot of the content right now is regurgitated from the wealth of similar posts out there. I've done my best to link to my sources, check them out!

 __About me:__ I got serious about coding in October of 2015, and have dedicated my life to getting better at the expense of basically everything else. I've done my best to avoid publishing errors or bad practices but please let me know if something is erroneous or could be better implemented!
